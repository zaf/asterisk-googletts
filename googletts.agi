#!/usr/bin/env perl

#
# AGI script that uses Google's translate text to speech engine.
#
# Copyright (C) 2011, Lefteris Zafiris
#
# This program is free software, distributed under the terms of
# the GNU General Public License Version 2. See the COPYING file
# at the top of the source tree.
#

use warnings;
use strict;
use File::Temp qw(tempfile);
use File::Copy qw(copy);
use File::Path qw(mkpath);
use Digest::MD5 qw(md5_hex);
use LWP::UserAgent;

$| = 1;

my %AGI;
my @text;
my $line;
my $result;
my $filename;
my $fexten;
my $request;
my $response;
my $intkey     = "";
my $url        = "http://translate.google.com/translate_tts";
my $lang       = "en";
my $samplerate = 8000;
my $cachedir   = "/tmp";
my $usecache   = 1;
my $sox        = `/usr/bin/which sox`;
my $mpg123     = `/usr/bin/which mpg123`;

if (!$sox || !$mpg123) {
	print STDERR " -- googleTTS: sox or mpg123 is missing. Aborting.\n";
	exit 0;
}

# Store AGI input #
while(<STDIN>) {
	chomp;
	last if (!length($_));
	$AGI{$1} = $2 if (/^agi_(\w+)\:\s+(.*)$/);
}

# Checking input text #
$AGI{arg_1} =~ s/^\s+|\s+$//g;
if (length($AGI{arg_1}) == 0) {
	print STDERR " -- googleTTS: No text passed for synthesis.\n";
	exit 0;
} elsif (length($AGI{arg_1}) > 100) {
	# Split input to comply with google tts requirements #
	$AGI{arg_1} .= ".";
	@text = $AGI{arg_1} =~ /.{0,100}[.,!?;]|.{0,100}\W/gms;
} else {
	@text = ($AGI{arg_1});
}

# Setting language #
$lang = $AGI{arg_2} if ($AGI{arg_2} =~ /[a-z]{2}/);

# Setting interrupt keys #
$intkey = "0123456789#*" if ($AGI{arg_3} eq "any");
$intkey = $AGI{arg_3} if ($AGI{arg_3} =~ /[0-9#*]+/);

# Setting filename extension according to sample rate. #
if ($samplerate == 8000) {
	$fexten = "sln";
} elsif ($samplerate == 12000) {
	$fexten = "sln12";
} elsif ($samplerate == 16000) {
	$fexten = "sln16";
} elsif ($samplerate == 24000) { 
	$fexten = "sln24"; 
} else {
	$fexten = "sln";
	$samplerate = 8000;
}

# Check cache path size #
if ($usecache && ((length($cachedir) + 38 ) > 2048)) {
	print STDERR " -- googleTTS: Cache path size exceeds limit. Disabling cache.\n";
	$usecache = 0;
}

print "ANSWER\n";
$result = <STDIN>;
&checkresult($result);

my $ua = LWP::UserAgent->new;
$ua->agent("Mozilla/5.0 (X11; Linux; rv:8.0) Gecko/20100101");
$ua->timeout(10);

foreach $line (@text) {
	$line =~ s/^\s+|\s+$//g;
	last if (length($line) == 0);
	if ($usecache) {
		$filename = md5_hex($line);
		# Stream file from cache if it exists #
		if (-r "$cachedir/$filename.$fexten") {
			print STDERR " -- googleTTS: File already in cache.\n";
			print "STREAM FILE $cachedir/$filename \"$intkey\"\n";
			$result = <STDIN>;
			&checkresult($result);
			next;
		}
	}
	# Format text string, convert whitespace to + #
	$line =~ s/\s/+/g;
	$request = HTTP::Request->new('GET' => "$url?tl=$lang&q=$line");
	$response = $ua->request($request);
	if ($response->is_success) {
		my ($fh, $tmpname) = tempfile("ggl_XXXXXX", TMPDIR => 1, UNLINK => 1);
		$SIG{"HUP"} = \&cleanup("$tmpname");
		open($fh, ">", "$tmpname.mp3") or die " -- googleTTS: Cannot open file: $!";
		print $fh $response->content;
		close $fh;
		# Convert mp3 file to 16bit 8Khz mono raw #
		system("mpg123 -w $tmpname.wav $tmpname.mp3 > /dev/null 2>&1");
		system("sox $tmpname.wav -t raw -r $samplerate $tmpname.$fexten > /dev/null 2>&1");
		print "STREAM FILE $tmpname \"$intkey\"\n";
		my $result = <STDIN>;
		&checkresult($result);
		# Save file in cache #
		if ($usecache) {
			mkpath("$cachedir") if (!(-d "$cachedir"));
			print STDERR " -- googleTTS: Saving file to cache.\n";
			copy("$tmpname.$fexten", "$cachedir/$filename.$fexten");
		}
		&cleanup("$tmpname");
	} else {
		print STDERR " -- googleTTS: Failed to fetch file.\n";
	}
}
exit 0;

sub cleanup {
	my ($name) = @_;
	my $exten;
	foreach $exten ("mp3", "wav", $fexten) {
		unlink("$name.$exten") if ( -w "$name.$exten");
	}
}

sub checkresult {
	my ($res) = @_;
	chomp $res;
	if ($res =~ /^200/) {
		$res =~ /result=(-?\d+)/;
		if (!length($1)) {
			print STDERR " -- googleTTS: Command filed: ($res)\n";
			return 1;
		} else {
			#print STDERR " -- googleTTS: success: ($1)\n";
			return 0;
		}
	} else {
		print STDERR " -- googleTTS: Unexpected result '$res'\n";
		return 1;
	}
}
